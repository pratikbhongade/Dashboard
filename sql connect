import pyodbc
import pandas as pd
import dash
import dash_bootstrap_components as dbc
from dash import dcc, html
from dash.dependencies import Input, Output
from datetime import datetime, timedelta

# Specify the database name you identified in SSMS
database_name = 'ASPIRE'  # Replace with the actual database name

# Function to get the last business day
def get_last_business_day():
    today = datetime.today()
    if today.weekday() == 0:  # Monday
        last_business_day = today - timedelta(days=3)
    elif today.weekday() == 6:  # Sunday
        last_business_day = today - timedelta(days=2)
    else:  # Any other day (Tuesday to Saturday)
        last_business_day = today - timedelta(days=1)
    
    # Ensure the date is within the current month
    if last_business_day.month != today.month:
        last_business_day = today.replace(day=1) - timedelta(days=1)
        while last_business_day.weekday() >= 5:  # Skip weekends
            last_business_day -= timedelta(days=1)
    
    return last_business_day

# Get the default date
default_date = get_last_business_day().strftime('%Y-%m-%d')

# Initialize the Dash app with Bootstrap CSS
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Layout of the dashboard
app.layout = dbc.Container([
    dbc.Row([
        dbc.Col(html.H1("Mainframe Job Status Dashboard", className='text-center mb-4'), width=12),
    ], className='border mb-3 align-items-center'),
    dbc.Row([
        dbc.Col(
            [
                dbc.InputGroup(
                    [
                        dcc.DatePickerSingle(
                            id='date-picker',
                            display_format='YYYY-MM-DD',
                            date=default_date,  # Default date
                            className='form-control'
                        ),
                        dbc.InputGroupText("ðŸ“…")  # Emoji for the calendar
                    ], 
                    className='d-flex justify-content-end'
                )
            ], 
            width=4, className='ml-auto'
        )
    ], className='border mb-3 justify-content-end'),
    dbc.Row([
        dbc.Col([
            dbc.Card(
                dbc.CardBody([
                    html.H4("UnLock Online Job", className='card-title'),
                    html.Div(id='unlock-online-table')
                ]),
                className='mb-4 border'
            )
        ], width=12)
    ], className='border mb-3'),
    dbc.Row([
        dbc.Col([
            dcc.Dropdown(
                id='job-name-dropdown',
                options=[],
                placeholder="Select a Job Name",
                className='mb-4'
            )
        ], width=6),
        dbc.Col([
            dcc.Dropdown(
                id='status-dropdown',
                options=[],
                placeholder="Select Job Status",
                className='mb-4'
            )
        ], width=6)
    ], className='border mb-3'),
    dbc.Row([
        dbc.Col([
            html.Div(id='job-table-container')
        ], width=12)
    ], className='border')
], fluid=True, className='p-4 bg-light rounded-3 shadow')

# Callback to update the tables and dropdowns based on the selected date
@app.callback(
    [Output('unlock-online-table', 'children'),
     Output('job-name-dropdown', 'options'),
     Output('status-dropdown', 'options'),
     Output('job-table-container', 'children')],
    [Input('date-picker', 'date'),
     Input('job-name-dropdown', 'value'),
     Input('status-dropdown', 'value')]
)
def update_dashboard(selected_date, selected_job, selected_status):
    # Connect to SQL Server
    conn_str = (
        r'DRIVER={SQL Server};'
        r'SERVER=SDC01ASRSQTD01\TSQLINT0;'
        r'DATABASE=' + database_name + r';'
        r'Trusted_Connection=yes;'
    )
    conn = pyodbc.connect(conn_str)

    # Query the data
    query = f"""
    SELECT JobName, StartTime, EndTime, Status 
    FROM Job_StatsVW
    WHERE ProcessingDate='{selected_date}' 
    ORDER BY StartTime DESC
    """
    df = pd.read_sql(query, conn)

    # Close the connection
    conn.close()

    # Format datetime columns
    df['StartDate'] = pd.to_datetime(df['StartTime']).dt.strftime('%Y-%m-%d')
    df['StartTime'] = pd.to_datetime(df['StartTime']).dt.strftime('%I:%M:%S %p')
    df['EndDate'] = pd.to_datetime(df['EndTime']).dt.strftime('%Y-%m-%d')
    df['EndTime'] = pd.to_datetime(df['EndTime']).dt.strftime('%I:%M:%S %p')

    # Separate the "UnLock Online" job
    unlock_online_df = df[df['JobName'] == 'UnLock Online']
    other_jobs_df = df[df['JobName'] != 'UnLock Online']

    # Create tables and dropdown options
    unlock_online_table = dbc.Table.from_dataframe(unlock_online_df[['JobName', 'StartDate', 'StartTime', 'EndDate', 'EndTime', 'Status']], striped=True, bordered=True, hover=True, className='table-dark')
    
    job_name_options = [{'label': job, 'value': job} for job in other_jobs_df['JobName'].unique()]
    job_status_options = [{'label': status, 'value': status} for status in other_jobs_df['Status'].unique()]

    filtered_df = other_jobs_df
    if selected_job:
        filtered_df = filtered_df[filtered_df['JobName'] == selected_job]
    if selected_status:
        filtered_df = filtered_df[filtered_df['Status'] == selected_status]

    job_table_header = [html.Thead(html.Tr([html.Th(col) for col in ['JobName', 'StartDate', 'StartTime', 'EndDate', 'EndTime', 'Status']], className='bg-primary text-white'))]
    job_table_body = [html.Tbody([html.Tr([html.Td(filtered_df.iloc[i][col]) for col in ['JobName', 'StartDate', 'StartTime', 'EndDate', 'EndTime', 'Status']]) for i in range(len(filtered_df))])]

    job_table = dbc.Table(job_table_header + job_table_body, striped=True, bordered=True, hover=True)

    return unlock_online_table, job_name_options, job_status_options, job_table

if __name__ == '__main__':
    app.run_server(debug=True)
