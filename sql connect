import pyodbc
import pandas as pd
import dash
import dash_bootstrap_components as dbc
from dash import dcc, html
from dash.dependencies import Input, Output
from datetime import datetime, timedelta

# List of bank holidays
bank_holidays = [
    "2024-01-01",  # New Year's Day
    "2024-01-15",  # Martin Luther King, Jr. Day
    "2024-05-27",  # Memorial Day
    "2024-06-19",  # Juneteenth National Independence Day
    "2024-07-04",  # Independence Day
    "2024-09-02",  # Labor Day
    "2024-11-28",  # Thanksgiving Day
    "2024-12-25"   # Christmas
]

# Function to get the last business day
def get_last_business_day():
    today = datetime.today()
    last_business_day = today

    while last_business_day.weekday() >= 5 or last_business_day.strftime('%Y-%m-%d') in bank_holidays:
        last_business_day -= timedelta(days=1)
    
    return last_business_day

# Get the default date
default_date = get_last_business_day().strftime('%Y-%m-%d')

# Initialize the Dash app with Bootstrap CSS
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Layout of the dashboard
app.layout = dbc.Container([
    dbc.Row([
        dbc.Col(html.H1("Mainframe Job Status Dashboard", className='text-center mb-4'), width=8),
        dbc.Col([
            dbc.InputGroup([
                dcc.DatePickerSingle(
                    id='date-picker',
                    display_format='YYYY-MM-DD',
                    date=default_date,  # Default date
                    className='form-control'
                ),
                html.Span(
                    "ðŸ“…", 
                    id='calendar-icon',
                    style={'cursor': 'pointer', 'margin-left': '-30px'}
                )
            ], className='d-flex justify-content-end')
        ], width=4)
    ], className='border mb-3 align-items-center'),
    dbc.Row([
        dbc.Col([
            dbc.Card(
                dbc.CardBody([
                    html.H4("UnLock Online Job", className='card-title'),
                    html.Div(id='unlock-online-table')
                ]),
                className='mb-4 border'
            )
        ], width=12)
    ], className='border mb-3'),
    dbc.Row([
        dbc.Col([
            dcc.Dropdown(
                id='job-name-dropdown',
                options=[],
                placeholder="Select a Job Name",
                className='mb-4'
            )
        ], width=6),
        dbc.Col([
            dcc.Dropdown(
                id='status-dropdown',
                options=[],
                placeholder="Select Job Status",
                className='mb-4'
            )
        ], width=6)
    ], className='border mb-3'),
    dbc.Row([
        dbc.Col([
            html.Div(id='job-table-container')
        ], width=12)
    ], className='border')
], fluid=True, className='p-4 bg-light rounded-3 shadow')

# Callback to update the tables and dropdowns based on the selected date
@app.callback(
    [Output('unlock-online-table', 'children'),
     Output('job-name-dropdown', 'options'),
     Output('status-dropdown', 'options'),
     Output('job-table-container', 'children')],
    [Input('date-picker', 'date'),
     Input('job-name-dropdown', 'value'),
     Input('status-dropdown', 'value')]
)
def update_dashboard(selected_date, selected_job, selected_status):
    if selected_date in bank_holidays or datetime.strptime(selected_date, '%Y-%m-%d').weekday() >= 5:
        # Display a message if the selected date is a bank holiday or a weekend
        message = html.Div(
            [
                html.H4("Bank Holiday: No Data Available", className='text-center text-danger')
            ]
        )
        return message, [], [], message

    # Connect to SQL Server
    conn_str = (
        r'DRIVER={SQL Server};'
        r'SERVER=SDC01ASRSQTD01\TSQLINT0;'
        r'DATABASE=' + database_name + r';'
        r'Trusted_Connection=yes;'
    )
    conn = pyodbc.connect(conn_str)

    # Updated SQL query with selective date in JSH.StartTime
    query = f"""
    SELECT CASE 
               WHEN DATEPART(hour, JSH.StartTime) < 14 THEN CONVERT(varchar, DATEADD(day, -1, JSH.StartTime), 23) 
               ELSE CONVERT(varchar, JSH.StartTime, 23) 
           END as ProcessingDate, 
           JSJ.JobStreamJoboid as Joboid, 
           JSJ.Name as JobName,
           CONVERT(datetime, JSH.StartTime AT TIME ZONE 'UTC' AT TIME ZONE 'Eastern Standard Time') AS [StartTime], 
           CONVERT(datetime, JSH.EndTime AT TIME ZONE 'UTC' AT TIME ZONE 'Eastern Standard Time') AS [EndTime], 
           JSH.Status, 
           JSH.Message 
    FROM JobStreamTaskHistory JSH
    LEFT JOIN JobStreamTask JST ON JSH.JobStreamTaskOid = JST.JobStreamTaskoid 
    JOIN JobStreamJob JSJ ON JSJ.JobStreamJoboid = JST.JobStreamJoboid
    WHERE JSH.StartTime >= '{selected_date} 00:00:00' AND JSH.StartTime < DATEADD(day, 1, '{selected_date}')
    UNION
    SELECT CASE 
               WHEN DATEPART(hour, JSH.StartTime) < 14 THEN CONVERT(varchar, DATEADD(day, -1, JSH.StartTime), 23) 
               ELSE CONVERT(varchar, JSH.StartTime, 23) 
           END as ProcessingDate, 
           JSJ.JobStreamJoboid as Joboid, 
           JSJ.Name as JobName, 
           CONVERT(datetime, (JSH.StartTime)) AS [StartTime], 
           CONVERT(datetime, (JSH.EndTime)) AS [EndTime], 
           JSH.Status, 
           JSH.Message 
    FROM JobStreamTaskHistory JSH 
    LEFT JOIN JobStreamTask JST ON JSH.JobStreamTaskOid = JST.JobStreamTaskoid 
    JOIN JobStreamJob JSJ ON JSJ.JobStreamJoboid = JST.JobStreamJoboid
    WHERE JSH.StartTime >= '{selected_date} 00:00:00' AND JSH.StartTime < DATEADD(day, 1, '{selected_date}')
    ORDER BY StartTime DESC
    """
    df = pd.read_sql(query, conn)

    # Close the connection
    conn.close()

    # Format datetime columns
    df['StartDate'] = pd.to_datetime(df['StartTime']).dt.strftime('%Y-%m-%d')
    df['StartTime'] = pd.to_datetime(df['StartTime']).dt.strftime('%I:%M:%S %p')
    df['EndDate'] = pd.to_datetime(df['EndTime']).dt.strftime('%Y-%m-%d')
    df['EndTime'] = pd.to_datetime(df['EndTime']).dt.strftime('%I:%M:%S %p')

    # Separate the "UnLock Online" job
    unlock_online_df = df[df['JobName'] == 'UnLock Online']
    other_jobs_df = df[df['JobName'] != 'UnLock Online']

    # Create tables and dropdown options
    unlock_online_table = dbc.Table.from_dataframe(unlock_online_df[['JobName', 'StartDate', 'StartTime', 'EndDate', 'EndTime', 'Status']], striped=True, bordered=True, hover=True, className='table-dark')
    
    job_name_options = [{'label': job, 'value': job} for job in other_jobs_df['JobName'].unique()]
    job_status_options = [{'label': status, 'value': status} for status in other_jobs_df['Status'].unique()]

    filtered_df = other_jobs_df
    if selected_job:
        filtered_df = filtered_df[filtered_df['JobName'] == selected_job]
    if selected_status:
        filtered_df = filtered_df[filtered_df['Status'] == selected_status]

    job_table_header = [html.Thead(html.Tr([html.Th(col) for col in ['JobName', 'StartDate', 'StartTime', 'EndDate', 'EndTime', 'Status']], className='bg-primary text-white'))]
    job_table_body = [html.Tbody([html.Tr([html.Td(filtered_df.iloc[i][col]) for col in ['JobName', 'StartDate', 'StartTime', 'EndDate', 'EndTime', 'Status']]) for i in range(len(filtered_df))])]

    job_table = dbc.Table(job_table_header + job_table_body, striped=True, bordered=True, hover=True)

    return unlock_online_table, job_name_options, job_status_options, job_table

# JavaScript to handle the calendar icon click
app.clientside_callback(
    """
    function(n_clicks) {
        if (n_clicks > 0) {
            document.querySelector('.DateInput_input').focus();
        }
        return '';
    }
    """,
    Output('calendar-icon', 'children'),
    [Input('calendar-icon', 'n_clicks')]
)

if __name__ == '__main__':
    app.run_server(debug=True)
